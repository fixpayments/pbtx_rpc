// @generated by protoc-gen-es v1.0.0 with parameter "target=ts"
// @generated from file pbtx.proto (package pbtx, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum pbtx.KeyType
 */
export enum KeyType {
  /**
   * @generated from enum value: EOSIO_KEY = 0;
   */
  EOSIO_KEY = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyType)
proto3.util.setEnumType(KeyType, "pbtx.KeyType", [
  { no: 0, name: "EOSIO_KEY" },
]);

/**
 * @generated from message pbtx.TransactionBody
 */
export class TransactionBody extends Message<TransactionBody> {
  /**
   * network identity
   *
   * @generated from field: fixed64 network_id = 1;
   */
  networkId = protoInt64.zero;

  /**
   * actor account ID
   *
   * @generated from field: fixed64 actor = 2;
   */
  actor = protoInt64.zero;

  /**
   * optional list of co-signing accounts (maximum 4)
   *
   * @generated from field: repeated fixed64 cosignors = 3;
   */
  cosignors: bigint[] = [];

  /**
   * actorâ€™s transaction sequence number
   *
   * @generated from field: uint32 seqnum = 4;
   */
  seqnum = 0;

  /**
   * previous TransactionBody's hash: first 8 bytes of sha256,
   * stored as big-endian (first byte of the sha256 hash in
   * higherst byte of prevhash)
   *
   * @generated from field: fixed64 prev_hash = 5;
   */
  prevHash = protoInt64.zero;

  /**
   * network-specific transaction type. PBTX does not interpret the
   * type and content, and passes them over for processing
   *
   * @generated from field: uint32 transaction_type = 6;
   */
  transactionType = 0;

  /**
   * transaction content in protobuf format (max length 16384)
   *
   * @generated from field: bytes transaction_content = 7;
   */
  transactionContent = new Uint8Array(0);

  constructor(data?: PartialMessage<TransactionBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.TransactionBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network_id", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 2, name: "actor", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "cosignors", kind: "scalar", T: 6 /* ScalarType.FIXED64 */, repeated: true },
    { no: 4, name: "seqnum", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "prev_hash", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 6, name: "transaction_type", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "transaction_content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionBody {
    return new TransactionBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionBody {
    return new TransactionBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionBody {
    return new TransactionBody().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionBody | PlainMessage<TransactionBody> | undefined, b: TransactionBody | PlainMessage<TransactionBody> | undefined): boolean {
    return proto3.util.equals(TransactionBody, a, b);
  }
}

/**
 * @generated from message pbtx.Transaction
 */
export class Transaction extends Message<Transaction> {
  /**
   * protobuf-encoded TransactionBody
   *
   * @generated from field: bytes body = 1;
   */
  body = new Uint8Array(0);

  /**
   * array of authorities. Each authority signs a sha256 hash of the
   * body bytes. The actor's authority should go first, followed by
   * cosignor authorities in exact order of cosignors field.
   * (maximum 8)
   *
   * @generated from field: repeated pbtx.Authority authorities = 2;
   */
  authorities: Authority[] = [];

  constructor(data?: PartialMessage<Transaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.Transaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "authorities", kind: "message", T: Authority, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transaction {
    return new Transaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transaction {
    return new Transaction().fromJsonString(jsonString, options);
  }

  static equals(a: Transaction | PlainMessage<Transaction> | undefined, b: Transaction | PlainMessage<Transaction> | undefined): boolean {
    return proto3.util.equals(Transaction, a, b);
  }
}

/**
 * Permission object allows specifying up to 16 public keys with their
 * weights to meet the threshold.
 *
 * @generated from message pbtx.Permission
 */
export class Permission extends Message<Permission> {
  /**
   * @generated from field: fixed64 actor = 1;
   */
  actor = protoInt64.zero;

  /**
   * @generated from field: uint32 threshold = 2;
   */
  threshold = 0;

  /**
   * @generated from field: repeated pbtx.KeyWeight keys = 3;
   */
  keys: KeyWeight[] = [];

  constructor(data?: PartialMessage<Permission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.Permission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actor", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 2, name: "threshold", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "keys", kind: "message", T: KeyWeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Permission {
    return new Permission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Permission {
    return new Permission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Permission {
    return new Permission().fromJsonString(jsonString, options);
  }

  static equals(a: Permission | PlainMessage<Permission> | undefined, b: Permission | PlainMessage<Permission> | undefined): boolean {
    return proto3.util.equals(Permission, a, b);
  }
}

/**
 * @generated from message pbtx.KeyWeight
 */
export class KeyWeight extends Message<KeyWeight> {
  /**
   * @generated from field: pbtx.PublicKey key = 1;
   */
  key?: PublicKey;

  /**
   * @generated from field: uint32 weight = 2;
   */
  weight = 0;

  constructor(data?: PartialMessage<KeyWeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.KeyWeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: PublicKey },
    { no: 2, name: "weight", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyWeight {
    return new KeyWeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyWeight {
    return new KeyWeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyWeight {
    return new KeyWeight().fromJsonString(jsonString, options);
  }

  static equals(a: KeyWeight | PlainMessage<KeyWeight> | undefined, b: KeyWeight | PlainMessage<KeyWeight> | undefined): boolean {
    return proto3.util.equals(KeyWeight, a, b);
  }
}

/**
 * for EOSIO_KEY key type, the key_bytes contains a binary
 * representation of a public key in EOSIO compatible format.
 *
 * @generated from message pbtx.PublicKey
 */
export class PublicKey extends Message<PublicKey> {
  /**
   * @generated from field: pbtx.KeyType type = 1;
   */
  type = KeyType.EOSIO_KEY;

  /**
   * @generated from field: bytes key_bytes = 2;
   */
  keyBytes = new Uint8Array(0);

  constructor(data?: PartialMessage<PublicKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.PublicKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(KeyType) },
    { no: 2, name: "key_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey {
    return new PublicKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJsonString(jsonString, options);
  }

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean {
    return proto3.util.equals(PublicKey, a, b);
  }
}

/**
 * Authority object contains signatures using one or more keys
 * specified in Permission object. A valid Authority object should
 * have the sum of matched key weights equal or higher to
 * Permission.threshold value.
 *
 * @generated from message pbtx.Authority
 */
export class Authority extends Message<Authority> {
  /**
   * @generated from field: pbtx.KeyType type = 1;
   */
  type = KeyType.EOSIO_KEY;

  /**
   * @generated from field: repeated bytes sigs = 2;
   */
  sigs: Uint8Array[] = [];

  constructor(data?: PartialMessage<Authority>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.Authority";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(KeyType) },
    { no: 2, name: "sigs", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Authority {
    return new Authority().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Authority {
    return new Authority().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Authority {
    return new Authority().fromJsonString(jsonString, options);
  }

  static equals(a: Authority | PlainMessage<Authority> | undefined, b: Authority | PlainMessage<Authority> | undefined): boolean {
    return proto3.util.equals(Authority, a, b);
  }
}

/**
 * Transactionns are sent to a blockchain (such as EOSIO), and the
 * blockchain registers the event with a timestamp and transaction
 * ID. This message contains a copy of PBTX transaction and the
 * corresponding blockchain transaction attributes.
 *
 * @generated from message pbtx.TransactionHistoryEntry
 */
export class TransactionHistoryEntry extends Message<TransactionHistoryEntry> {
  /**
   * protobuf-encoded Transaction
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction = new Uint8Array(0);

  /**
   * microseconds since Epoch as recorded in the backend blockchain
   *
   * @generated from field: fixed64 backend_timestamp = 2;
   */
  backendTimestamp = protoInt64.zero;

  /**
   * transaction ID in the blockchain (normally, a 256-bit hash)
   *
   * @generated from field: bytes backend_trxid = 3;
   */
  backendTrxid = new Uint8Array(0);

  constructor(data?: PartialMessage<TransactionHistoryEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "pbtx.TransactionHistoryEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "backend_timestamp", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "backend_trxid", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionHistoryEntry {
    return new TransactionHistoryEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionHistoryEntry {
    return new TransactionHistoryEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionHistoryEntry {
    return new TransactionHistoryEntry().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionHistoryEntry | PlainMessage<TransactionHistoryEntry> | undefined, b: TransactionHistoryEntry | PlainMessage<TransactionHistoryEntry> | undefined): boolean {
    return proto3.util.equals(TransactionHistoryEntry, a, b);
  }
}

